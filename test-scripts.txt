
Postman — это HTTP-клиент для тестирования API. HTTP-клиенты тестируют отправку запросов с клиента на сервер и получение ответа от сервера.

В постмане мы можем использовать вкладку Tests в своих запросах и коллекциях для написания тестов, которые будут выполняться, когда Postman получит ответ от API, которому вы отправили запрос.
Вы можете добавить столько тестов, сколько вам нужно для каждого запроса. 
Когда вы добавляете тесты в Collections, они будут выполняться после каждого запроса внутри нее.

Postman отображает фрагменты кода (snippets) справа от области сценария. 
Вы можете добавить их, чтобы опробовать распространенные сценарии, и настроить их в соответствии с вашими потребностями и деталями запроса / ответа.


---------- Начало работы с тестами ------------
Чтобы попробовать написать тестовый сценарий в первый раз, откройте запрос в приложении Postman и откройте вкладку Tests. Введите следующий код JavaScript:

pm.test("Status code is 200", function () {
  pm.response.to.have.status(200);
});

Этот код использует библиотеку pm для запуска метода test. Тесты постмана могут использовать синтаксис BDD библиотеки утверждений Chai, который предоставляет возможности для оптимизации того, насколько удобочитаемы ваши тесты для вас и ваших сотрудников. 
В этом примере код использует цепочки BDD to.have для выражения утверждения.

Этот тест проверяет код ответа, возвращаемый API. Если код ответа 200, тест будет пройден, в противном случае он завершится неудачей. 
Нажмите Отправить и проверьте вывод результатов теста в области ответов.

Попробуйте изменить код состояния в коде утверждения и запустить его снова, чтобы увидеть, как результаты теста выглядят по-разному, когда они проходят или не проходят.

Вы можете строить свои тестовые утверждения (выражения) разными способами, в зависимости от того, 
как вы хотите, чтобы выводились результаты.
Следующий код является альтернативным способом достижения того же теста, что и выше, с использованием ожидаемого синтаксиса:

pm.test("Status code is 200", () => {
  pm.expect(pm.response.code).to.eql(200);
});





------------ Использование нескольких утверждений ------------
Ваши тесты могут включать несколько утверждений как часть одного теста, вы можете использовать это для группировки связанных утверждений.

pm.test("The response has all properties", () => {
    // разобрать json ответ и проверить три свойства
    const responseJson = pm.response.json();
    pm.expect(responseJson.type).to.eql('vip');
    pm.expect(responseJson.name).to.be.a('string');
    pm.expect(responseJson.id).to.have.lengthOf(1);
});

Если какое-либо из содержащихся утверждений завершится неудачно, тест в целом завершится неудачно. Все утверждения должны быть успешными, чтобы тест прошел успешно.


Either pm.response.json() for JSON or pm.response.text() if you need just the raw plain text.

expect('foo').to.be.a('string');
expect({a: 1}).to.be.an('object');
expect(null).to.be.a('null');
expect(undefined).to.be.an('undefined');
expect(new Error).to.be.an('error');
expect(Promise.resolve()).to.be.a('promise');
expect(new Float32Array).to.be.a('float32array');
expect(Symbol()).to.be.a('symbol');


============== Парсинг (анализ) данных тела ответа ==============
Чтобы выполнить тестовые утверждения на ваши ответы, сначала вам нужно будет разобрать данные в объект JavaScript, который ваши утверждения могут использовать.

Для анализа (парсинга) данных JSON используйте следующий синтаксис:
--> const responseJson = pm.response.json();

Для разбора XML используйте следующий синтаксис:
--> const responseJson = xml2Json(pm.response.text());

Для разбора CSV используйте утилиту CSV-разбора (csv-parse/lib/sync):
const parse = require('csv-parse/lib/sync');
const responseJson = parse(pm.response.text());




Language Chains
The following are provided as chainable getters to improve the readability of your assertions.

Chains

to
be
been
is
that
which
and
has
have
with
at
of
same
but
does
still
also
.not
Negates all assertions that follow in the chain.

expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
Just because you can negate any assertion with .not doesn’t mean you should. With great power comes great responsibility. It’s often best to assert that the one expected output was produced, rather than asserting that one of countless unexpected outputs wasn’t produced. See individual assertions for specific guidance.