
Postman — это HTTP-клиент для тестирования API. HTTP-клиенты тестируют отправку запросов с клиента на сервер и получение ответа от сервера.

В постмане мы можем использовать вкладку Tests в своих запросах и коллекциях для написания тестов, которые будут выполняться, когда Postman получит ответ от API, которому вы отправили запрос.
Вы можете добавить столько тестов, сколько вам нужно для каждого запроса. 
Когда вы добавляете тесты в Collections, они будут выполняться после каждого запроса внутри нее.

Postman отображает фрагменты кода (snippets) справа от области сценария. 
Вы можете добавить их, чтобы опробовать распространенные сценарии, и настроить их в соответствии с вашими потребностями и деталями запроса / ответа.


---------- Начало работы с тестами ------------
Чтобы попробовать написать тестовый сценарий в первый раз, откройте запрос в приложении Postman и откройте вкладку Tests. Введите следующий код JavaScript:

pm.test("Status code is 200", function () {
  pm.response.to.have.status(200);
});

Этот код использует библиотеку pm для запуска метода test. Тесты постмана могут использовать синтаксис BDD библиотеки утверждений Chai, который предоставляет возможности для оптимизации того, насколько удобочитаемы ваши тесты для вас и ваших сотрудников. 
В этом примере код использует цепочки BDD to.have для выражения утверждения.

Этот тест проверяет код ответа, возвращаемый API. Если код ответа 200, тест будет пройден, в противном случае он завершится неудачей. 
Нажмите Отправить и проверьте вывод результатов теста в области ответов.

Попробуйте изменить код состояния в коде утверждения и запустить его снова, чтобы увидеть, как результаты теста выглядят по-разному, когда они проходят или не проходят.

Вы можете строить свои тестовые утверждения (выражения) разными способами, в зависимости от того, 
как вы хотите, чтобы выводились результаты.
Следующий код является альтернативным способом достижения того же теста, что и выше, с использованием ожидаемого синтаксиса:

pm.test("Status code is 200", () => {
  pm.expect(pm.response.code).to.eql(200);
});





------------ Использование нескольких утверждений ------------
Ваши тесты могут включать несколько утверждений как часть одного теста, вы можете использовать это для группировки связанных утверждений.

pm.test("The response has all properties", () => {
    // разобрать json ответ и проверить три свойства
    const responseJson = pm.response.json();
    pm.expect(responseJson.type).to.eql('vip');
    pm.expect(responseJson.name).to.be.a('string');
    pm.expect(responseJson.id).to.have.lengthOf(1);
});

Если какое-либо из содержащихся утверждений завершится неудачно, тест в целом завершится неудачно. Все утверждения должны быть успешными, чтобы тест прошел успешно.


Either pm.response.json() for JSON or pm.response.text() if you need just the raw plain text.

expect('foo').to.be.a('string');
expect({a: 1}).to.be.an('object');
expect(null).to.be.a('null');
expect(undefined).to.be.an('undefined');
expect(new Error).to.be.an('error');
expect(Promise.resolve()).to.be.a('promise');
expect(new Float32Array).to.be.a('float32array');
expect(Symbol()).to.be.a('symbol');


============== Парсинг (анализ) данных тела ответа ==============
Чтобы выполнить тестовые утверждения на ваши ответы, сначала вам нужно будет разобрать данные в объект JavaScript, который ваши утверждения могут использовать.

Для анализа (парсинга) данных JSON используйте следующий синтаксис:
--> const responseJson = pm.response.json();

Для разбора XML используйте следующий синтаксис:
--> const responseJson = xml2Json(pm.response.text());

Для разбора CSV используйте утилиту CSV-разбора (csv-parse/lib/sync):
const parse = require('csv-parse/lib/sync');
const responseJson = parse(pm.response.text());

Для разбора HTML используйте cheerio:
const $ = cheerio.load(pm.response.text());
//output the html for testing
console.log($.html());


--------- Как обрабатывать ответы, которые не разбираются ----------
Если вы не можете разобрать тело ответа на JavaScript, потому что он не отформатирован как JSON, XML, HTML, CSV
или любой другой доступный формат данных, вы все еще можете делать тестовые утверждения по данным.

Например, мы можем проверить, содержит ли тело ответа строку:
	pm.test("Body contains string",() => {
	  pm.expect(pm.response.text()).to.include("customer_id");
	});

Данное тестовое утверждение не покажет вам, где строка была встречена, потому что оно проводит тест на всем теле ответа.

Также, к примеру, мы можем проверить, соответствует ли ответ строке:
	pm.test("Body is string", function () {
	  pm.response.to.have.body("whole-body-text");
	});


------------ Проверка тела ответа ------------
Мы можем проверить конкретные значения в теле ответа:

/* Ответ имеет следующую структуру:
{
  "name": "Jane",
  "age": 23
},
*/
pm.test("Person is Jane", () => {
  const responseJson = pm.response.json();
  pm.expect(responseJson.name).to.eql("Jane");
  pm.expect(responseJson.age).to.eql(23);
});


---------- Проверка для кода состояния ответа ----------
pm.test("Status code is 201", () => {
  pm.response.to.have.status(201);
});

Если вы хотите проверить, что код состояния является одним из множества, 
включите их все в массив и используйте oneOf:
pm.test("Successful POST request", () => {
  pm.expect(pm.response.code).to.be.oneOf([201,202]);
});


Проверка текста кода состояния
pm.test("Status code name has string", () => {
  pm.response.to.have.status("Created");
});


-------------- Проверка наличия заголовка (хэдера) ответа -------------
pm.test("Content-Type header is present", () => {
  pm.response.to.have.header("Content-Type");
});


------ Проверка заголовка ответа, имеющего конкретное значение ------
pm.test("Content-Type header is application/json", () => {
  pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');
});


---------- Тестирование куки ----------

--- Проверка наличия cookie в ответе ---
pm.test("Cookie isLoggedIn is present", () => {
  pm.expect(pm.cookies.has('isLoggedIn')).to.be.true;
});

--- Тест (проверка) для конкретного значения cookie ---
pm.test("Cookie isLoggedIn has value 1", () => {
  pm.expect(pm.cookies.get('isLoggedIn')).to.eql('1');
});



----- Тест (проверка), что время ответа находится в заданном диапазоне -----
pm.test("Response time is less than 200ms", () => {
  pm.expect(pm.response.responseTime).to.be.below(200);
});


============= Примеры распространённых утверждений ==============
Мы можем проверить, имеет ли свойство ответа то же значение, что и переменная (в этом примере используется переменная среды):
pm.test("Response property matches environment variable", function () {
  pm.expect(pm.response.json().name).to.eql(pm.environment.get("name"));
});



----- Проверка типа данных любой части ответа -----

/* Ответ (Response) имеет следующую структуру:
{
  "name": "Jane",
  "age": 29,
  "hobbies": [
    "skating",
    "painting"
  ],
  "email": null
},
*/
const jsonData = pm.response.json();
pm.test("Test data type of the response", () => {
  pm.expect(jsonData).to.be.an("object");
  pm.expect(jsonData.name).to.be.a("string");
  pm.expect(jsonData.age).to.be.a("number");
  pm.expect(jsonData.hobbies).to.be.an("array");
  pm.expect(jsonData.website).to.be.undefined;
  pm.expect(jsonData.email).to.be.null;
});



------------- Проверка, что объект содержит ключи или свойства --------------
/* Response has the following structure:
{
  "a": 1,
  "b": 2
},
*/
pm.expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
pm.expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
pm.expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
pm.expect({a: 1}).to.have.property('a');
pm.expect({a: 1, b: 2}).to.be.an('object')
  .that.has.all.keys('a', 'b');








Проверка массива: является ли он пустым, содержит ли он определенные элементы:









Language Chains
The following are provided as chainable getters to improve the readability of your assertions.

Chains

to
be
been
is
that
which
and
has
have
with
at
of
same
but
does
still
also
.not
Negates all assertions that follow in the chain.

expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
Just because you can negate any assertion with .not doesn’t mean you should. With great power comes great responsibility. It’s often best to assert that the one expected output was produced, rather than asserting that one of countless unexpected outputs wasn’t produced. See individual assertions for specific guidance.